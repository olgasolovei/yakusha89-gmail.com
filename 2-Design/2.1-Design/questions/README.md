1. Які архітектурні типи програмного продукту вам відомі?

Архітектурні типи описують, як компоненти системи організовані та взаємодіють між собою. Основні типи:

Монолітна архітектура – всі компоненти програми об’єднані в одному великому додатку.

Клієнт-серверна архітектура – додаток розділений на серверну та клієнтську частини.

Шарова (Layered) архітектура – логіка програми розділена на шари (наприклад, презентаційний, бізнес-логіка, доступ до даних).

Мікросервісна архітектура – система складається з багатьох незалежних сервісів, що взаємодіють через API.

Подієва (Event-driven) архітектура – компоненти обмінюються подіями; часто використовується в системах реального часу.

Сервісно-орієнтована архітектура (SOA) – система складається зі взаємодіючих сервісів, що забезпечують бізнес-функції.

2. Які три рівні представлення визначають при описі архітектури?

При описі архітектури програмного продукту виділяють три основні рівні:

Концептуальний (Conceptual) – описує загальні компоненти системи та їх взаємодію без деталей реалізації.

Логічний (Logical) – показує внутрішню структуру системи, класи, модулі, зв’язки між ними.

Фізичний (Physical) – описує реальну реалізацію системи: сервери, бази даних, розгортання компонентів на конкретних машинах.

3. Які основні принципи декомпозиції вам відомі?

Декомпозиція – це розбиття системи на частини для зручності розробки, тестування та підтримки. Основні принципи:

Розділення за функціоналом (Functional decomposition) – кожен модуль відповідає за окрему функцію.

Розділення за даними (Data decomposition) – модулі організовані навколо типів даних або структур.

Розділення за підсистемами (Subsystem decomposition) – виділення незалежних підсистем або сервісів.

Ієрархічна декомпозиція – побудова системи у вигляді дерева, де великі модулі діляться на менші.

4. Що означає, коли програмний модуль має Low Coupling?

Low Coupling (низька зв’язаність) означає, що модуль мінімально залежить від інших модулів.

Зміни в одному модулі не сильно впливають на інші.

Модулі легко тестувати та замінювати.

Система стає більш гнучкою та підтримуваною.

Приклад: якщо клас Notifier зміниться, RiskAnalyzer майже не постраждає, бо працює через абстракцію.
